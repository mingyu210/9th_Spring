markdown
## 계층형 구조 vs 도메인형 구조

**🗂️ 계층형 구조 (Layered Architecture)**

계층형 구조는 애플리케이션을 기능별로 나누어 각 기능이 독립적으로 동작하도록 하는 방식입니다. 예를 들어 `Controller`는 모두 `Controller` 패키지에 넣고, `Service`는 모두 `Service` 패키지에 넣는 식입니다.

```
com.example.projectname
├── controller
├── service
├── repository
├── domain
├── dto
├── config
└── exception
```

**장점**

*   **명확한 역할 분리:** 각 계층이 명확한 역할을 가지므로, 코드를 이해하기 쉽습니다.
*   **테스트 용이:** 각 계층별로 독립적으로 테스트할 수 있어 편리합니다.
*   **익숙한 패턴:** 많은 개발자들이 이미 알고 있는 패턴입니다.

**단점**

*   **계층 간 의존성:** 한 계층의 변경이 다른 계층에 영향을 미칠 수 있습니다.
*   **복잡성 증가:** 큰 프로젝트에서는 계층의 수가 늘어나 복잡해질 수 있습니다.
*   **특정 기능과 관련된 코드를 찾기가 어렵습니다.**

**🏷️ 도메인형 구조 (Domain-Driven Design, DDD)**

도메인형 구조는 도메인에 초점을 맞추어 코드를 구성하는 방식입니다. 이 방식에서는 관련된 기능들을 도메인 단위로 그룹화합니다. 예를 들어, 사용자 관련 클래스는 `user` 패키지에, 제품 관련 클래스는 `product` 패키지에 넣는 식입니다.

```
com.example.projectname
├── user
│   ├── controller
│   ├── service
│   ├── repository
│   ├── domain
│   ├── dto
│   └── exception
├── product
│   ├── controller
│   ├── service
│   ├── repository
│   ├── domain
│   ├── dto
│   └── exception
└── config
```

**장점**

*   **비즈니스 중심:** 비즈니스 로직이 명확하게 드러나 이해하기 쉽습니다.
*   **유연성:** 새로운 기능 추가 시 독립적으로 추가할 수 있습니다.
*   **변경에 강함:** 한 도메인의 변경이 다른 도메인에 영향을 미치지 않습니다.

**단점**

*   **도메인 간 코드 중복이 발생할 수 있습니다.**
*   **도메인 간 의존성 관리 어려움:** 여러 도메인이 협력해야 할 때 구조가 복잡해질 수 있습니다.

---

## JPA (Java Persistence API)

JPA(Java Persistence API)란 자바 언어로 DB에 명령을 내리는 도구로, 데이터를 객체 지향적으로 관리할 수 있게 해주는 인터페이스와 기능을 제공하는 API입니다.

JPA는 ORM 기술을 기반으로 합니다.

### ORM (Object-Relational Mapping) 이란?

객체 지향 프로그래밍 언어에서 사용되는 객체와 관계형 데이터베이스의 데이터 간의 매핑을 자동화하는 기법입니다. 개발자는 객체 지향 프로그래밍의 장점을 유지하면서 데이터베이스와의 상호작용을 쉽게 처리할 수 있습니다. ORM은 데이터베이스 테이블의 행을 객체로, 열을 객체의 속성으로 매핑하여 객체 지향 방식으로 데이터베이스를 조작할 수 있게 해줍니다.

**ORM 핵심 개념**

*   **매핑:** 객체와 데이터베이스 테이블 간의 대응 관계를 설정합니다.
    *   자바 클래스의 필드는 데이터베이스 테이블의 열에 매핑됩니다.
*   **엔티티:** 데이터베이스 테이블에 대응하는 객체입니다.
    *   각 엔티티 인스턴스는 데이터베이스 테이블의 한 행을 나타냅니다.
*   **속성:** 엔티티 클래스의 필드는 데이터베이스 테이블의 열에 매핑됩니다.
    *   클래스의 `name` 속성은 테이블의 `name` 열에 매핑됩니다.
*   **연관 관계:** 객체 간의 관계를 정의하고 이를 데이터베이스 테이블 간의 외래 키 관계로 매핑합니다.
    *   일대일, 일대다, 다대일, 다대다 관계가 있습니다.

JPA를 구현한 대표적인 오픈소스로는 **Hibernate** 가 있습니다.

### Hibernate 핵심 개념

*   **객체-관계 매핑(ORM):** 자바 클래스와 데이터베이스 테이블 간의 매핑을 설정합니다.
    *   데이터베이스의 테이블을 자바 객체로, 테이블의 컬럼을 객체의 필드로 매핑합니다.
*   **데이터베이스 독립성:** 데이터베이스에 종속되지 않으며, 다양한 데이터베이스 시스템을 지원합니다.
    *   데이터베이스 변경 시 코드 수정이 최소화됩니다.
*   **투명한 지속성:** 데이터베이스에 접근하는 코드를 작성하지 않고도 객체의 상태를 데이터베이스에 자동으로 동기화합니다.
    *   엔티티 객체의 생명주기를 관리합니다.
*   **HQL (Hibernate Query Language):** 객체 지향 쿼리 언어로, SQL과 유사하지만 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 수행합니다.
    *   복잡한 조회, 집계 등을 객체 지향적으로 표현할 수 있습니다.
*   **캐싱:** 1차 캐시와 2차 캐시를 지원하여 성능을 최적화합니다.
    *   자주 조회되는 데이터를 메모리에 저장하여 데이터베이스 접근을 줄입니다.

Spring Data JPA는 기본적인 CRUD 메서드를 제공하는 라이브러리입니다.

**Spring Data JPA 사용법**

```java
public interface MemberRepository extends JpaRepository<Member, Long> {}
```

*   `MemberRepository`를 인터페이스로 선언하고 `JpaRepository`를 상속 받습니다.
*   `Type`: 사용할 Repository의 기준이 되는 Entity의 타입을 기입합니다.
*   `Id`: 기입된 Entity의 Primary Key 자료형을 기입합니다.
---
## N+1 문제

N+1 문제는 JPA의 연관 관계가 있는 Entity를 조회(SELECT)할 경우에, **결과로 조회된 데이터 개수(N)**만큼 연관 관계가 있는 데이터를 추가로 조회하는 쿼리를 발생시키는 문제입니다.

### 지연 로딩(LAZY) vs 즉시 로딩(EAGER)

*   **지연 로딩(LAZY):** 연관된 엔티티를 실제로 사용할 때까지 조회를 미루는 방식
    *   DB에서 데이터를 바로 가져오지 않고, 필요할 때 쿼리를 실행
*   **즉시 로딩(EAGER):** 연관된 엔티티를 항상 함께 조회하는 방식
    *   해당 엔티티를 조회할 때, 연관된 데이터도 즉시 조인해서 가져옴

> ⚠️ EAGER 로딩을 사용해도 N+1 문제가 항상 해결되는 것은 아닙니다.  
> JPA는 항상 조인을 사용하는 것이 아니기 때문입니다.

**해결법**

1.  **Fetch Join 사용:** JPQL이나 Criteria API를 사용하여 쿼리를 작성할 때 연관된 엔티티를 함께 조회하도록 명시적으로 지정하는 방법
2.  **EntityGraph 사용:** 엔티티 조회 시 연관된 엔티티를 어떻게 로딩할지 미리 정의할 수 있습니다. 이를 통해 패치 조인과 유사한 효과를 얻을 수 있지만, 더 선언적이고 유연한 방식으로 연관 엔티티의 로딩 전략을 제어할 수 있습니다.

> ⚠️ 주의  
> 컬렉션(`fetch = OneToMany`)을 여러 개 동시에 조인하면 문제가 발생할 수 있음  
> 예: 한 회원이 여러 주문과 여러 주소를 가질 경우

---

## 기본 키 생성 전략

JPA가 제공하는 기본 키 할당 방법은 직접 할당 방식과 자동 생성 방식이 있습니다.

직접 할당 방식은 애플리케이션에서 기본 키를 직접 할당하는 방식이고, 자동 생성 방식은 DB에 할당을 위임하거나 기본 키를 생성해 주는 별도의 수단을 통해 할당하는 것입니다.

**직접 할당 방식**

직접 할당 방식을 사용할 경우 Entity를 생성할 때 Key Column에 `@Id`사용

```java
@Id
private long id;
```

**자동 생성 방식**

자동 생성 방식을 사용할 경우 `@Id`와 `@GeneratedValue`를 사용

1.  **IDENTITY:** DB가 자동으로 1씩 증가시켜서 PK 생성
    *   주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용
2.  **SEQUENCE (DB 시퀀스 사용):** DB Sequence를 사용해 기본 키를 할당하는 방식
    *   Sequence 전략을 지원하는 Oracle, PostgreSQL, DB2, H2 DB에서 주로 사용
3.  **TABLE (별도의 테이블로 관리):** Key 생성 Table을 사용하는 전략

**비유**

*   IDENTITY = “학생이 등록할 때, 바로 DB가 출석 번호를 붙여주는 것” → MySQL, AUTO_INCREMENT
*   SEQUENCE = “학교에서 미리 번호표를 만들어서 학생에게 나눠주는 것” → Oracle, PostgreSQL 시퀀스
*   TABLE = “학교에 번호표를 보관하는 전용 상자를 두고, 학생이 등록할 때 상자에서 하나씩 꺼내서 번호를 붙이는 것” → 번호를 한 명씩 꺼내서 사용하고, 상자에 기록 업데이트.
